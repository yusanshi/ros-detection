diff --git a/detected_objects_visualizer/include/visualize_rects.h b/detected_objects_visualizer/include/visualize_rects.h
index 0c9726b..f3ede6b 100644
--- a/detected_objects_visualizer/include/visualize_rects.h
+++ b/detected_objects_visualizer/include/visualize_rects.h
@@ -20,64 +20,66 @@
 #ifndef _VISUALIZERECTS_H
 #define _VISUALIZERECTS_H
 
-#include <vector>
-#include <string>
-#include <sstream>
 #include <cmath>
 #include <iomanip>
+#include <sstream>
+#include <string>
+#include <vector>
 
 #include <ros/ros.h>
 
-#include <std_msgs/Header.h>
-#include <sensor_msgs/Image.h>
-#include <image_transport/image_transport.h>
 #include <cv_bridge/cv_bridge.h>
+#include <image_transport/image_transport.h>
+#include <sensor_msgs/Image.h>
+#include <std_msgs/Header.h>
 #include <opencv2/highgui/highgui.hpp>
 
 #include <message_filters/subscriber.h>
-#include <message_filters/synchronizer.h>
 #include <message_filters/sync_policies/approximate_time.h>
+#include <message_filters/synchronizer.h>
 
 #include "autoware_msgs/DetectedObject.h"
 #include "autoware_msgs/DetectedObjectArray.h"
 
 #define __APP_NAME__ "visualize_rects"
 
-class VisualizeRects
-{
-private:
-  std::string input_topic_;
+class VisualizeRects {
+   private:
+    std::string input_topic_;
+    std::string ros_namespace_;
 
-  ros::NodeHandle node_handle_;
-  ros::Subscriber subscriber_detected_objects_;
-  image_transport::Subscriber subscriber_image_;
+    ros::NodeHandle node_handle_;
+    ros::Subscriber subscriber_detected_objects_;
+    image_transport::Subscriber subscriber_image_;
 
-  message_filters::Subscriber<autoware_msgs::DetectedObjectArray> *detection_filter_subscriber_;
-  message_filters::Subscriber<sensor_msgs::Image> *image_filter_subscriber_;
+    message_filters::Subscriber<autoware_msgs::DetectedObjectArray>
+        *detection_filter_subscriber_;
+    message_filters::Subscriber<sensor_msgs::Image> *image_filter_subscriber_;
 
-  ros::Publisher publisher_image_;
+    ros::Publisher publisher_image_;
 
-  cv::Mat image_;
-  std_msgs::Header image_header_;
+    cv::Mat image_;
+    std_msgs::Header image_header_;
 
-  typedef
-  message_filters::sync_policies::ApproximateTime<sensor_msgs::Image,
-    autoware_msgs::DetectedObjectArray> SyncPolicyT;
+    typedef message_filters::sync_policies::ApproximateTime<
+        sensor_msgs::Image, autoware_msgs::DetectedObjectArray>
+        SyncPolicyT;
 
-  message_filters::Synchronizer<SyncPolicyT>
-    *detections_synchronizer_;
+    message_filters::Synchronizer<SyncPolicyT> *detections_synchronizer_;
 
-  void
-  SyncedDetectionsCallback(
-    const sensor_msgs::Image::ConstPtr &in_image_msg,
-    const autoware_msgs::DetectedObjectArray::ConstPtr &in_range_detections);
+    void SyncedDetectionsCallback(
+        const sensor_msgs::Image::ConstPtr &in_image_msg,
+        const autoware_msgs::DetectedObjectArray::ConstPtr
+            &in_range_detections);
 
-  bool IsObjectValid(const autoware_msgs::DetectedObject &in_object);
+    bool IsObjectValid(const autoware_msgs::DetectedObject &in_object);
 
-  cv::Mat ObjectsToRects(cv::Mat in_image, const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects);
+    cv::Mat ObjectsToRects(
+        cv::Mat in_image,
+        const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects);
 
-public:
-  VisualizeRects();
+   public:
+    VisualizeRects(std::string image_src_topic);
 };
 
 #endif  // _VISUALIZERECTS_H
diff --git a/detected_objects_visualizer/src/visualize_rects.cpp b/detected_objects_visualizer/src/visualize_rects.cpp
index 57941ee..528a2df 100644
--- a/detected_objects_visualizer/src/visualize_rects.cpp
+++ b/detected_objects_visualizer/src/visualize_rects.cpp
@@ -19,151 +19,116 @@
 
 #include "visualize_rects.h"
 
-VisualizeRects::VisualizeRects()
-{
-  ros::NodeHandle private_nh_("~");
-
-  ros::NodeHandle nh;
-
-  std::string image_src_topic;
-  std::string object_src_topic;
-  std::string image_out_topic;
-
-  private_nh_.param<std::string>("image_src", image_src_topic, "/image_raw");
-  private_nh_.param<std::string>("object_src", object_src_topic, "/detection/image_detector/objects");
-  private_nh_.param<std::string>("image_out", image_out_topic, "/image_rects");
-
-  //get namespace from topic
-  std::string ros_namespace = image_src_topic;
-  std::size_t found_pos = ros_namespace.rfind("/");//find last / from topic name to extract namespace
-  std::cout << ros_namespace << std::endl;
-  if (found_pos!=std::string::npos)
-    ros_namespace.erase(found_pos, ros_namespace.length()-found_pos);
-  std::cout << ros_namespace << std::endl;
-  image_out_topic = ros_namespace + image_out_topic;
-
-  image_filter_subscriber_ = new message_filters::Subscriber<sensor_msgs::Image>(private_nh_,
-                                                                                 image_src_topic,
-                                                                                             1);
-  ROS_INFO("[%s] image_src: %s", __APP_NAME__, image_src_topic.c_str());
-  detection_filter_subscriber_ = new message_filters::Subscriber<autoware_msgs::DetectedObjectArray>(private_nh_,
-                                                                                                     object_src_topic,
-                                                                                             1);
-  ROS_INFO("[%s] object_src: %s", __APP_NAME__, object_src_topic.c_str());
-
-  detections_synchronizer_ =
-    new message_filters::Synchronizer<SyncPolicyT>(SyncPolicyT(10),
-                                                   *image_filter_subscriber_,
-                                                   *detection_filter_subscriber_);
-  detections_synchronizer_->registerCallback(
-    boost::bind(&VisualizeRects::SyncedDetectionsCallback, this, _1, _2));
-
-
-  publisher_image_ = node_handle_.advertise<sensor_msgs::Image>(
-    image_out_topic, 1);
-  ROS_INFO("[%s] image_out: %s", __APP_NAME__, image_out_topic.c_str());
+VisualizeRects::VisualizeRects(std::string image_src_topic) {
+    ros::NodeHandle private_nh_("~");
 
-}
+    ros_namespace_ = ros::this_node::getNamespace();
+    if (ros_namespace_.substr(0, 2) == "//") {
+        ros_namespace_.erase(ros_namespace_.begin());
+    }
+    if (image_src_topic.substr(0, 1) != "/") {
+        image_src_topic = "/" + image_src_topic;
+    }
 
-void
-VisualizeRects::SyncedDetectionsCallback(
-  const sensor_msgs::Image::ConstPtr &in_image_msg,
-  const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects)
-{
-  try
-  {
-    image_ = cv_bridge::toCvShare(in_image_msg, "bgr8")->image;
-    cv::Mat drawn_image;
-    drawn_image = ObjectsToRects(image_, in_objects);
-    sensor_msgs::ImagePtr drawn_msg = cv_bridge::CvImage(in_image_msg->header, "bgr8", drawn_image).toImageMsg();
-    publisher_image_.publish(drawn_msg);
-  }
-  catch (cv_bridge::Exception& e)
-  {
-    ROS_ERROR("[%s] Could not convert from '%s' to 'bgr8'.", __APP_NAME__, in_image_msg->encoding.c_str());
-  }
+    std::string object_src_topic;
+    std::string image_out_topic;
+
+    private_nh_.param<std::string>("object_src", object_src_topic, "/objects");
+    private_nh_.param<std::string>("image_out", image_out_topic,
+                                   "/image_rects");
+
+    image_src_topic = ros_namespace_ + image_src_topic;
+    object_src_topic = ros_namespace_ + object_src_topic;
+    image_out_topic = ros_namespace_ + image_out_topic;
+
+    image_filter_subscriber_ =
+        new message_filters::Subscriber<sensor_msgs::Image>(private_nh_,
+                                                            image_src_topic, 1);
+    detection_filter_subscriber_ =
+        new message_filters::Subscriber<autoware_msgs::DetectedObjectArray>(
+            private_nh_, object_src_topic, 1);
+    detections_synchronizer_ = new message_filters::Synchronizer<SyncPolicyT>(
+        SyncPolicyT(10), *image_filter_subscriber_,
+        *detection_filter_subscriber_);
+    detections_synchronizer_->registerCallback(
+        boost::bind(&VisualizeRects::SyncedDetectionsCallback, this, _1, _2));
+
+    publisher_image_ =
+        node_handle_.advertise<sensor_msgs::Image>(image_out_topic, 1);
 }
 
-cv::Mat
-VisualizeRects::ObjectsToRects(cv::Mat in_image, const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects)
-{
-  cv::Mat final_image = in_image.clone();
-  for (auto const &object: in_objects->objects)
-  {
-    if (IsObjectValid(object))
-    {
-      cv::Rect rect;
-      rect.x = object.x;
-      rect.y = object.y;
-      rect.width = object.width;
-      rect.height = object.height;
-
-      if (rect.x+rect.width >= in_image.cols)
-        rect.width = in_image.cols -rect.x - 1;
-
-      if (rect.y+rect.height >= in_image.rows)
-        rect.height = in_image.rows -rect.y - 1;
-
-      //draw rectangle
-      cv::rectangle(final_image,
-                    rect,
-                    cv::Scalar(244,134,66),
-                    4,
-                    CV_AA);
-
-      //draw label
-      std::string label = "";
-      if (!object.label.empty() && object.label != "unknown")
-      {
-        label = object.label;
-      }
-      int font_face = cv::FONT_HERSHEY_DUPLEX;
-      double font_scale = 1.5;
-      int thickness = 1;
-
-      int baseline=0;
-      cv::Size text_size = cv::getTextSize(label,
-                                          font_face,
-                                          font_scale,
-                                          thickness,
-                                          &baseline);
-      baseline += thickness;
-
-      cv::Point text_origin(object.x - text_size.height,object.y);
-
-      cv::rectangle(final_image,
-                    text_origin + cv::Point(0, baseline),
-                    text_origin + cv::Point(text_size.width, -text_size.height),
-                    cv::Scalar(0,0,0),
-                    CV_FILLED,
-                    CV_AA,
-                    0);
-
-      cv::putText(final_image,
-                  label,
-                  text_origin,
-                  font_face,
-                  font_scale,
-                  cv::Scalar::all(255),
-                  thickness,
-                  CV_AA,
-                  false);
+void VisualizeRects::SyncedDetectionsCallback(
+    const sensor_msgs::Image::ConstPtr &in_image_msg,
+    const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects) {
+    try {
+        image_ = cv_bridge::toCvShare(in_image_msg, "bgr8")->image;
+        cv::Mat drawn_image;
+        drawn_image = ObjectsToRects(image_, in_objects);
+        sensor_msgs::ImagePtr drawn_msg =
+            cv_bridge::CvImage(in_image_msg->header, "bgr8", drawn_image)
+                .toImageMsg();
+        publisher_image_.publish(drawn_msg);
+    } catch (cv_bridge::Exception &e) {
+        ROS_ERROR("[%s] Could not convert from '%s' to 'bgr8'.", __APP_NAME__,
+                  in_image_msg->encoding.c_str());
+    }
+}
 
+cv::Mat VisualizeRects::ObjectsToRects(
+    cv::Mat in_image,
+    const autoware_msgs::DetectedObjectArray::ConstPtr &in_objects) {
+    cv::Mat final_image = in_image.clone();
+    for (auto const &object : in_objects->objects) {
+        if (IsObjectValid(object)) {
+            cv::Rect rect;
+            rect.x = object.x;
+            rect.y = object.y;
+            rect.width = object.width;
+            rect.height = object.height;
+
+            if (rect.x + rect.width >= in_image.cols)
+                rect.width = in_image.cols - rect.x - 1;
+
+            if (rect.y + rect.height >= in_image.rows)
+                rect.height = in_image.rows - rect.y - 1;
+
+            // draw rectangle
+            cv::rectangle(final_image, rect, cv::Scalar(244, 134, 66), 4,
+                          CV_AA);
+
+            // draw label
+            std::string label = "";
+            if (!object.label.empty() && object.label != "unknown") {
+                label = object.label;
+            }
+            int font_face = cv::FONT_HERSHEY_DUPLEX;
+            double font_scale = 0.75;
+            int thickness = 0.5;
+
+            int baseline = 0;
+            cv::Size text_size = cv::getTextSize(label, font_face, font_scale,
+                                                 thickness, &baseline);
+            baseline += thickness;
+
+            cv::Point text_origin(object.x - text_size.height, object.y);
+
+            cv::rectangle(
+                final_image, text_origin + cv::Point(0, baseline),
+                text_origin + cv::Point(text_size.width, -text_size.height),
+                cv::Scalar(0, 0, 0), CV_FILLED, CV_AA, 0);
+
+            cv::putText(final_image, label, text_origin, font_face, font_scale,
+                        cv::Scalar::all(255), thickness, CV_AA, false);
+        }
+    }
+    return final_image;
+}  // ObjectsToBoxes
+
+bool VisualizeRects::IsObjectValid(
+    const autoware_msgs::DetectedObject &in_object) {
+    if (!in_object.valid || in_object.width < 0 || in_object.height < 0 ||
+        in_object.x < 0 || in_object.y < 0) {
+        return false;
     }
-  }
-  return final_image;
-}//ObjectsToBoxes
-
-bool VisualizeRects::IsObjectValid(const autoware_msgs::DetectedObject &in_object)
-{
-  if (!in_object.valid ||
-      in_object.width < 0 ||
-      in_object.height < 0 ||
-      in_object.x < 0 ||
-      in_object.y < 0
-    )
-  {
-    return false;
-  }
-  return true;
-}//end IsObjectValid
\ No newline at end of file
+    return true;
+}  // end IsObjectValid
\ No newline at end of file
diff --git a/detected_objects_visualizer/src/visualize_rects_main.cpp b/detected_objects_visualizer/src/visualize_rects_main.cpp
index 0da1b4f..1fbe355 100644
--- a/detected_objects_visualizer/src/visualize_rects_main.cpp
+++ b/detected_objects_visualizer/src/visualize_rects_main.cpp
@@ -19,11 +19,14 @@
 
 #include "visualize_rects.h"
 
-int main(int argc, char** argv)
-{
-  ros::init(argc, argv, "visualize_rects");
-  VisualizeRects app;
-  ros::spin();
+int main(int argc, char** argv) {
+    ros::init(argc, argv, "visualize_rects");
+    if (argc != 2) {
+        ROS_ERROR("Usage: visualize_rects <image topic>");
+        return 1;
+    }
+    VisualizeRects app(std::string{argv[1]});
+    ros::spin();
 
-  return 0;
+    return 0;
 }
